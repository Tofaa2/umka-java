// Generated by jextract

package me.tofaa.umka.generated;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class UnsafeUmka extends UnsafeUmka$shared {

    UnsafeUmka() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    private static final int _VCRT_COMPILER_PREPROCESSOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _VCRT_COMPILER_PREPROCESSOR 1
     * }
     */
    public static int _VCRT_COMPILER_PREPROCESSOR() {
        return _VCRT_COMPILER_PREPROCESSOR;
    }
    private static final int _SAL_VERSION = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SAL_VERSION 20
     * }
     */
    public static int _SAL_VERSION() {
        return _SAL_VERSION;
    }
    private static final int __SAL_H_VERSION = (int)180000000L;
    /**
     * {@snippet lang=c :
     * #define __SAL_H_VERSION 180000000
     * }
     */
    public static int __SAL_H_VERSION() {
        return __SAL_H_VERSION;
    }
    private static final int _USE_DECLSPECS_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_DECLSPECS_FOR_SAL 0
     * }
     */
    public static int _USE_DECLSPECS_FOR_SAL() {
        return _USE_DECLSPECS_FOR_SAL;
    }
    private static final int _USE_ATTRIBUTES_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_ATTRIBUTES_FOR_SAL 0
     * }
     */
    public static int _USE_ATTRIBUTES_FOR_SAL() {
        return _USE_ATTRIBUTES_FOR_SAL;
    }
    private static final int _CRT_PACKING = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _CRT_PACKING 8
     * }
     */
    public static int _CRT_PACKING() {
        return _CRT_PACKING;
    }
    private static final int _HAS_EXCEPTIONS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _HAS_EXCEPTIONS 1
     * }
     */
    public static int _HAS_EXCEPTIONS() {
        return _HAS_EXCEPTIONS;
    }
    private static final int _HAS_CXX17 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX17 0
     * }
     */
    public static int _HAS_CXX17() {
        return _HAS_CXX17;
    }
    private static final int _HAS_CXX20 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX20 0
     * }
     */
    public static int _HAS_CXX20() {
        return _HAS_CXX20;
    }
    private static final int _HAS_CXX23 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX23 0
     * }
     */
    public static int _HAS_CXX23() {
        return _HAS_CXX23;
    }
    private static final int _HAS_CXX26 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX26 0
     * }
     */
    public static int _HAS_CXX26() {
        return _HAS_CXX26;
    }
    private static final int _HAS_NODISCARD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_NODISCARD 0
     * }
     */
    public static int _HAS_NODISCARD() {
        return _HAS_NODISCARD;
    }
    private static final int WCHAR_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN 0
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 65535
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 65535
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int true_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define true 1
     * }
     */
    public static int true_() {
        return true_;
    }
    private static final int false_ = (int)0L;
    /**
     * {@snippet lang=c :
     * #define false 0
     * }
     */
    public static int false_() {
        return false_;
    }
    private static final int __bool_true_false_are_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __bool_true_false_are_defined 1
     * }
     */
    public static int __bool_true_false_are_defined() {
        return __bool_true_false_are_defined;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = UnsafeUmka.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *va_list
     * }
     */
    public static final AddressLayout va_list = UnsafeUmka.C_POINTER;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void __va_start(va_list *, ...)
     * }
     */
    public static class __va_start {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                UnsafeUmka.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__va_start");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __va_start(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void __va_start(va_list *, ...)
         * }
         */
        public static __va_start makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __va_start(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__va_start", x0, x1);
                }
                 spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long size_t
     * }
     */
    public static final OfLong size_t = UnsafeUmka.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = UnsafeUmka.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long intptr_t
     * }
     */
    public static final OfLong intptr_t = UnsafeUmka.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef _Bool __vcrt_bool
     * }
     */
    public static final OfBoolean __vcrt_bool = UnsafeUmka.C_BOOL;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wchar_t
     * }
     */
    public static final OfShort wchar_t = UnsafeUmka.C_SHORT;

    private static class __security_init_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__security_init_cookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static FunctionDescriptor __security_init_cookie$descriptor() {
        return __security_init_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static MethodHandle __security_init_cookie$handle() {
        return __security_init_cookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static MemorySegment __security_init_cookie$address() {
        return __security_init_cookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static void __security_init_cookie() {
        var mh$ = __security_init_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_init_cookie");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_check_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            UnsafeUmka.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__security_check_cookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __security_check_cookie$descriptor() {
        return __security_check_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __security_check_cookie$handle() {
        return __security_check_cookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MemorySegment __security_check_cookie$address() {
        return __security_check_cookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static void __security_check_cookie(long _StackCookie) {
        var mh$ = __security_check_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_check_cookie", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __report_gsfailure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            UnsafeUmka.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__report_gsfailure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __report_gsfailure$descriptor() {
        return __report_gsfailure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __report_gsfailure$handle() {
        return __report_gsfailure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MemorySegment __report_gsfailure$address() {
        return __report_gsfailure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static void __report_gsfailure(long _StackCookie) {
        var mh$ = __report_gsfailure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__report_gsfailure", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_cookie$constants {
        public static final OfLong LAYOUT = UnsafeUmka.C_LONG_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__security_cookie").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static OfLong __security_cookie$layout() {
        return __security_cookie$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static MemorySegment __security_cookie$segment() {
        return __security_cookie$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static long __security_cookie() {
        return __security_cookie$constants.SEGMENT.get(__security_cookie$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static void __security_cookie(long varValue) {
        __security_cookie$constants.SEGMENT.set(__security_cookie$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = UnsafeUmka.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = UnsafeUmka.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = UnsafeUmka.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = UnsafeUmka.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = UnsafeUmka.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = UnsafeUmka.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = UnsafeUmka.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = UnsafeUmka.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_least8_t
     * }
     */
    public static final OfByte int_least8_t = UnsafeUmka.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int_least16_t
     * }
     */
    public static final OfShort int_least16_t = UnsafeUmka.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int_least32_t
     * }
     */
    public static final OfInt int_least32_t = UnsafeUmka.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int_least64_t
     * }
     */
    public static final OfLong int_least64_t = UnsafeUmka.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = UnsafeUmka.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = UnsafeUmka.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = UnsafeUmka.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = UnsafeUmka.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = UnsafeUmka.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int int_fast16_t
     * }
     */
    public static final OfInt int_fast16_t = UnsafeUmka.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = UnsafeUmka.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = UnsafeUmka.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = UnsafeUmka.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_fast16_t
     * }
     */
    public static final OfInt uint_fast16_t = UnsafeUmka.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = UnsafeUmka.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = UnsafeUmka.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long intmax_t
     * }
     */
    public static final OfLong intmax_t = UnsafeUmka.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = UnsafeUmka.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef double max_align_t
     * }
     */
    public static final OfDouble max_align_t = UnsafeUmka.C_DOUBLE;
    private static final int UMKA_HOOK_CALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UMKA_HOOK_CALL = 0
     * }
     */
    public static int UMKA_HOOK_CALL() {
        return UMKA_HOOK_CALL;
    }
    private static final int UMKA_HOOK_RETURN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UMKA_HOOK_RETURN = 1
     * }
     */
    public static int UMKA_HOOK_RETURN() {
        return UMKA_HOOK_RETURN;
    }
    private static final int UMKA_NUM_HOOKS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UMKA_NUM_HOOKS = 2
     * }
     */
    public static int UMKA_NUM_HOOKS() {
        return UMKA_NUM_HOOKS;
    }

    private static class umkaAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Umka *umkaAlloc()
     * }
     */
    public static FunctionDescriptor umkaAlloc$descriptor() {
        return umkaAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Umka *umkaAlloc()
     * }
     */
    public static MethodHandle umkaAlloc$handle() {
        return umkaAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Umka *umkaAlloc()
     * }
     */
    public static MemorySegment umkaAlloc$address() {
        return umkaAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Umka *umkaAlloc()
     * }
     */
    public static MemorySegment umkaAlloc() {
        var mh$ = umkaAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaAlloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_BOOL,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_INT,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_INT,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_BOOL,
            UnsafeUmka.C_BOOL,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool umkaInit(Umka *umka, const char *fileName, const char *sourceString, int stackSize, void *reserved, int argc, char **argv, _Bool fileSystemEnabled, _Bool implLibsEnabled, UmkaWarningCallback warningCallback)
     * }
     */
    public static FunctionDescriptor umkaInit$descriptor() {
        return umkaInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool umkaInit(Umka *umka, const char *fileName, const char *sourceString, int stackSize, void *reserved, int argc, char **argv, _Bool fileSystemEnabled, _Bool implLibsEnabled, UmkaWarningCallback warningCallback)
     * }
     */
    public static MethodHandle umkaInit$handle() {
        return umkaInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool umkaInit(Umka *umka, const char *fileName, const char *sourceString, int stackSize, void *reserved, int argc, char **argv, _Bool fileSystemEnabled, _Bool implLibsEnabled, UmkaWarningCallback warningCallback)
     * }
     */
    public static MemorySegment umkaInit$address() {
        return umkaInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool umkaInit(Umka *umka, const char *fileName, const char *sourceString, int stackSize, void *reserved, int argc, char **argv, _Bool fileSystemEnabled, _Bool implLibsEnabled, UmkaWarningCallback warningCallback)
     * }
     */
    public static boolean umkaInit(MemorySegment umka, MemorySegment fileName, MemorySegment sourceString, int stackSize, MemorySegment reserved, int argc, MemorySegment argv, boolean fileSystemEnabled, boolean implLibsEnabled, MemorySegment warningCallback) {
        var mh$ = umkaInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaInit", umka, fileName, sourceString, stackSize, reserved, argc, argv, fileSystemEnabled, implLibsEnabled, warningCallback);
            }
            return (boolean)mh$.invokeExact(umka, fileName, sourceString, stackSize, reserved, argc, argv, fileSystemEnabled, implLibsEnabled, warningCallback);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaCompile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_BOOL,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaCompile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool umkaCompile(Umka *umka)
     * }
     */
    public static FunctionDescriptor umkaCompile$descriptor() {
        return umkaCompile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool umkaCompile(Umka *umka)
     * }
     */
    public static MethodHandle umkaCompile$handle() {
        return umkaCompile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool umkaCompile(Umka *umka)
     * }
     */
    public static MemorySegment umkaCompile$address() {
        return umkaCompile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool umkaCompile(Umka *umka)
     * }
     */
    public static boolean umkaCompile(MemorySegment umka) {
        var mh$ = umkaCompile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaCompile", umka);
            }
            return (boolean)mh$.invokeExact(umka);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_INT,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int umkaRun(Umka *umka)
     * }
     */
    public static FunctionDescriptor umkaRun$descriptor() {
        return umkaRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int umkaRun(Umka *umka)
     * }
     */
    public static MethodHandle umkaRun$handle() {
        return umkaRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int umkaRun(Umka *umka)
     * }
     */
    public static MemorySegment umkaRun$address() {
        return umkaRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int umkaRun(Umka *umka)
     * }
     */
    public static int umkaRun(MemorySegment umka) {
        var mh$ = umkaRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaRun", umka);
            }
            return (int)mh$.invokeExact(umka);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_INT,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int umkaCall(Umka *umka, UmkaFuncContext *fn)
     * }
     */
    public static FunctionDescriptor umkaCall$descriptor() {
        return umkaCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int umkaCall(Umka *umka, UmkaFuncContext *fn)
     * }
     */
    public static MethodHandle umkaCall$handle() {
        return umkaCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int umkaCall(Umka *umka, UmkaFuncContext *fn)
     * }
     */
    public static MemorySegment umkaCall$address() {
        return umkaCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int umkaCall(Umka *umka, UmkaFuncContext *fn)
     * }
     */
    public static int umkaCall(MemorySegment umka, MemorySegment fn) {
        var mh$ = umkaCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaCall", umka, fn);
            }
            return (int)mh$.invokeExact(umka, fn);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void umkaFree(Umka *umka)
     * }
     */
    public static FunctionDescriptor umkaFree$descriptor() {
        return umkaFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void umkaFree(Umka *umka)
     * }
     */
    public static MethodHandle umkaFree$handle() {
        return umkaFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void umkaFree(Umka *umka)
     * }
     */
    public static MemorySegment umkaFree$address() {
        return umkaFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void umkaFree(Umka *umka)
     * }
     */
    public static void umkaFree(MemorySegment umka) {
        var mh$ = umkaFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaFree", umka);
            }
            mh$.invokeExact(umka);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UmkaError *umkaGetError(Umka *umka)
     * }
     */
    public static FunctionDescriptor umkaGetError$descriptor() {
        return umkaGetError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UmkaError *umkaGetError(Umka *umka)
     * }
     */
    public static MethodHandle umkaGetError$handle() {
        return umkaGetError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UmkaError *umkaGetError(Umka *umka)
     * }
     */
    public static MemorySegment umkaGetError$address() {
        return umkaGetError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UmkaError *umkaGetError(Umka *umka)
     * }
     */
    public static MemorySegment umkaGetError(MemorySegment umka) {
        var mh$ = umkaGetError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetError", umka);
            }
            return (MemorySegment)mh$.invokeExact(umka);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaAlive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_BOOL,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaAlive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool umkaAlive(Umka *umka)
     * }
     */
    public static FunctionDescriptor umkaAlive$descriptor() {
        return umkaAlive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool umkaAlive(Umka *umka)
     * }
     */
    public static MethodHandle umkaAlive$handle() {
        return umkaAlive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool umkaAlive(Umka *umka)
     * }
     */
    public static MemorySegment umkaAlive$address() {
        return umkaAlive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool umkaAlive(Umka *umka)
     * }
     */
    public static boolean umkaAlive(MemorySegment umka) {
        var mh$ = umkaAlive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaAlive", umka);
            }
            return (boolean)mh$.invokeExact(umka);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaAsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaAsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *umkaAsm(Umka *umka)
     * }
     */
    public static FunctionDescriptor umkaAsm$descriptor() {
        return umkaAsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *umkaAsm(Umka *umka)
     * }
     */
    public static MethodHandle umkaAsm$handle() {
        return umkaAsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *umkaAsm(Umka *umka)
     * }
     */
    public static MemorySegment umkaAsm$address() {
        return umkaAsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *umkaAsm(Umka *umka)
     * }
     */
    public static MemorySegment umkaAsm(MemorySegment umka) {
        var mh$ = umkaAsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaAsm", umka);
            }
            return (MemorySegment)mh$.invokeExact(umka);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaAddModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_BOOL,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaAddModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool umkaAddModule(Umka *umka, const char *fileName, const char *sourceString)
     * }
     */
    public static FunctionDescriptor umkaAddModule$descriptor() {
        return umkaAddModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool umkaAddModule(Umka *umka, const char *fileName, const char *sourceString)
     * }
     */
    public static MethodHandle umkaAddModule$handle() {
        return umkaAddModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool umkaAddModule(Umka *umka, const char *fileName, const char *sourceString)
     * }
     */
    public static MemorySegment umkaAddModule$address() {
        return umkaAddModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool umkaAddModule(Umka *umka, const char *fileName, const char *sourceString)
     * }
     */
    public static boolean umkaAddModule(MemorySegment umka, MemorySegment fileName, MemorySegment sourceString) {
        var mh$ = umkaAddModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaAddModule", umka, fileName, sourceString);
            }
            return (boolean)mh$.invokeExact(umka, fileName, sourceString);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaAddFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_BOOL,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaAddFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool umkaAddFunc(Umka *umka, const char *name, UmkaExternFunc func)
     * }
     */
    public static FunctionDescriptor umkaAddFunc$descriptor() {
        return umkaAddFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool umkaAddFunc(Umka *umka, const char *name, UmkaExternFunc func)
     * }
     */
    public static MethodHandle umkaAddFunc$handle() {
        return umkaAddFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool umkaAddFunc(Umka *umka, const char *name, UmkaExternFunc func)
     * }
     */
    public static MemorySegment umkaAddFunc$address() {
        return umkaAddFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool umkaAddFunc(Umka *umka, const char *name, UmkaExternFunc func)
     * }
     */
    public static boolean umkaAddFunc(MemorySegment umka, MemorySegment name, MemorySegment func) {
        var mh$ = umkaAddFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaAddFunc", umka, name, func);
            }
            return (boolean)mh$.invokeExact(umka, name, func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_BOOL,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool umkaGetFunc(Umka *umka, const char *moduleName, const char *fnName, UmkaFuncContext *fn)
     * }
     */
    public static FunctionDescriptor umkaGetFunc$descriptor() {
        return umkaGetFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool umkaGetFunc(Umka *umka, const char *moduleName, const char *fnName, UmkaFuncContext *fn)
     * }
     */
    public static MethodHandle umkaGetFunc$handle() {
        return umkaGetFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool umkaGetFunc(Umka *umka, const char *moduleName, const char *fnName, UmkaFuncContext *fn)
     * }
     */
    public static MemorySegment umkaGetFunc$address() {
        return umkaGetFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool umkaGetFunc(Umka *umka, const char *moduleName, const char *fnName, UmkaFuncContext *fn)
     * }
     */
    public static boolean umkaGetFunc(MemorySegment umka, MemorySegment moduleName, MemorySegment fnName, MemorySegment fn) {
        var mh$ = umkaGetFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetFunc", umka, moduleName, fnName, fn);
            }
            return (boolean)mh$.invokeExact(umka, moduleName, fnName, fn);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetCallStack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_BOOL,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_INT,
            UnsafeUmka.C_INT,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetCallStack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool umkaGetCallStack(Umka *umka, int depth, int nameSize, int *offset, char *fileName, char *fnName, int *line)
     * }
     */
    public static FunctionDescriptor umkaGetCallStack$descriptor() {
        return umkaGetCallStack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool umkaGetCallStack(Umka *umka, int depth, int nameSize, int *offset, char *fileName, char *fnName, int *line)
     * }
     */
    public static MethodHandle umkaGetCallStack$handle() {
        return umkaGetCallStack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool umkaGetCallStack(Umka *umka, int depth, int nameSize, int *offset, char *fileName, char *fnName, int *line)
     * }
     */
    public static MemorySegment umkaGetCallStack$address() {
        return umkaGetCallStack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool umkaGetCallStack(Umka *umka, int depth, int nameSize, int *offset, char *fileName, char *fnName, int *line)
     * }
     */
    public static boolean umkaGetCallStack(MemorySegment umka, int depth, int nameSize, MemorySegment offset, MemorySegment fileName, MemorySegment fnName, MemorySegment line) {
        var mh$ = umkaGetCallStack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetCallStack", umka, depth, nameSize, offset, fileName, fnName, line);
            }
            return (boolean)mh$.invokeExact(umka, depth, nameSize, offset, fileName, fnName, line);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaSetHook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_INT,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaSetHook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void umkaSetHook(Umka *umka, UmkaHookEvent event, UmkaHookFunc hook)
     * }
     */
    public static FunctionDescriptor umkaSetHook$descriptor() {
        return umkaSetHook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void umkaSetHook(Umka *umka, UmkaHookEvent event, UmkaHookFunc hook)
     * }
     */
    public static MethodHandle umkaSetHook$handle() {
        return umkaSetHook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void umkaSetHook(Umka *umka, UmkaHookEvent event, UmkaHookFunc hook)
     * }
     */
    public static MemorySegment umkaSetHook$address() {
        return umkaSetHook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void umkaSetHook(Umka *umka, UmkaHookEvent event, UmkaHookFunc hook)
     * }
     */
    public static void umkaSetHook(MemorySegment umka, int event, MemorySegment hook) {
        var mh$ = umkaSetHook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaSetHook", umka, event, hook);
            }
            mh$.invokeExact(umka, event, hook);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaAllocData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_INT,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaAllocData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *umkaAllocData(Umka *umka, int size, UmkaExternFunc onFree)
     * }
     */
    public static FunctionDescriptor umkaAllocData$descriptor() {
        return umkaAllocData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *umkaAllocData(Umka *umka, int size, UmkaExternFunc onFree)
     * }
     */
    public static MethodHandle umkaAllocData$handle() {
        return umkaAllocData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *umkaAllocData(Umka *umka, int size, UmkaExternFunc onFree)
     * }
     */
    public static MemorySegment umkaAllocData$address() {
        return umkaAllocData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *umkaAllocData(Umka *umka, int size, UmkaExternFunc onFree)
     * }
     */
    public static MemorySegment umkaAllocData(MemorySegment umka, int size, MemorySegment onFree) {
        var mh$ = umkaAllocData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaAllocData", umka, size, onFree);
            }
            return (MemorySegment)mh$.invokeExact(umka, size, onFree);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaIncRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaIncRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void umkaIncRef(Umka *umka, void *ptr)
     * }
     */
    public static FunctionDescriptor umkaIncRef$descriptor() {
        return umkaIncRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void umkaIncRef(Umka *umka, void *ptr)
     * }
     */
    public static MethodHandle umkaIncRef$handle() {
        return umkaIncRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void umkaIncRef(Umka *umka, void *ptr)
     * }
     */
    public static MemorySegment umkaIncRef$address() {
        return umkaIncRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void umkaIncRef(Umka *umka, void *ptr)
     * }
     */
    public static void umkaIncRef(MemorySegment umka, MemorySegment ptr) {
        var mh$ = umkaIncRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaIncRef", umka, ptr);
            }
            mh$.invokeExact(umka, ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaDecRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaDecRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void umkaDecRef(Umka *umka, void *ptr)
     * }
     */
    public static FunctionDescriptor umkaDecRef$descriptor() {
        return umkaDecRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void umkaDecRef(Umka *umka, void *ptr)
     * }
     */
    public static MethodHandle umkaDecRef$handle() {
        return umkaDecRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void umkaDecRef(Umka *umka, void *ptr)
     * }
     */
    public static MemorySegment umkaDecRef$address() {
        return umkaDecRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void umkaDecRef(Umka *umka, void *ptr)
     * }
     */
    public static void umkaDecRef(MemorySegment umka, MemorySegment ptr) {
        var mh$ = umkaDecRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaDecRef", umka, ptr);
            }
            mh$.invokeExact(umka, ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetMapItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UmkaStackSlot.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetMapItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *umkaGetMapItem(Umka *umka, UmkaMap *map, UmkaStackSlot key)
     * }
     */
    public static FunctionDescriptor umkaGetMapItem$descriptor() {
        return umkaGetMapItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *umkaGetMapItem(Umka *umka, UmkaMap *map, UmkaStackSlot key)
     * }
     */
    public static MethodHandle umkaGetMapItem$handle() {
        return umkaGetMapItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *umkaGetMapItem(Umka *umka, UmkaMap *map, UmkaStackSlot key)
     * }
     */
    public static MemorySegment umkaGetMapItem$address() {
        return umkaGetMapItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *umkaGetMapItem(Umka *umka, UmkaMap *map, UmkaStackSlot key)
     * }
     */
    public static MemorySegment umkaGetMapItem(MemorySegment umka, MemorySegment map, MemorySegment key) {
        var mh$ = umkaGetMapItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetMapItem", umka, map, key);
            }
            return (MemorySegment)mh$.invokeExact(umka, map, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaMakeStr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaMakeStr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *umkaMakeStr(Umka *umka, const char *str)
     * }
     */
    public static FunctionDescriptor umkaMakeStr$descriptor() {
        return umkaMakeStr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *umkaMakeStr(Umka *umka, const char *str)
     * }
     */
    public static MethodHandle umkaMakeStr$handle() {
        return umkaMakeStr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *umkaMakeStr(Umka *umka, const char *str)
     * }
     */
    public static MemorySegment umkaMakeStr$address() {
        return umkaMakeStr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *umkaMakeStr(Umka *umka, const char *str)
     * }
     */
    public static MemorySegment umkaMakeStr(MemorySegment umka, MemorySegment str) {
        var mh$ = umkaMakeStr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaMakeStr", umka, str);
            }
            return (MemorySegment)mh$.invokeExact(umka, str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetStrLen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_INT,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetStrLen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int umkaGetStrLen(const char *str)
     * }
     */
    public static FunctionDescriptor umkaGetStrLen$descriptor() {
        return umkaGetStrLen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int umkaGetStrLen(const char *str)
     * }
     */
    public static MethodHandle umkaGetStrLen$handle() {
        return umkaGetStrLen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int umkaGetStrLen(const char *str)
     * }
     */
    public static MemorySegment umkaGetStrLen$address() {
        return umkaGetStrLen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int umkaGetStrLen(const char *str)
     * }
     */
    public static int umkaGetStrLen(MemorySegment str) {
        var mh$ = umkaGetStrLen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetStrLen", str);
            }
            return (int)mh$.invokeExact(str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaMakeDynArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaMakeDynArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void umkaMakeDynArray(Umka *umka, void *array, const UmkaType *type, int len)
     * }
     */
    public static FunctionDescriptor umkaMakeDynArray$descriptor() {
        return umkaMakeDynArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void umkaMakeDynArray(Umka *umka, void *array, const UmkaType *type, int len)
     * }
     */
    public static MethodHandle umkaMakeDynArray$handle() {
        return umkaMakeDynArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void umkaMakeDynArray(Umka *umka, void *array, const UmkaType *type, int len)
     * }
     */
    public static MemorySegment umkaMakeDynArray$address() {
        return umkaMakeDynArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void umkaMakeDynArray(Umka *umka, void *array, const UmkaType *type, int len)
     * }
     */
    public static void umkaMakeDynArray(MemorySegment umka, MemorySegment array, MemorySegment type, int len) {
        var mh$ = umkaMakeDynArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaMakeDynArray", umka, array, type, len);
            }
            mh$.invokeExact(umka, array, type, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetDynArrayLen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_INT,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetDynArrayLen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int umkaGetDynArrayLen(const void *array)
     * }
     */
    public static FunctionDescriptor umkaGetDynArrayLen$descriptor() {
        return umkaGetDynArrayLen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int umkaGetDynArrayLen(const void *array)
     * }
     */
    public static MethodHandle umkaGetDynArrayLen$handle() {
        return umkaGetDynArrayLen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int umkaGetDynArrayLen(const void *array)
     * }
     */
    public static MemorySegment umkaGetDynArrayLen$address() {
        return umkaGetDynArrayLen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int umkaGetDynArrayLen(const void *array)
     * }
     */
    public static int umkaGetDynArrayLen(MemorySegment array) {
        var mh$ = umkaGetDynArrayLen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetDynArrayLen", array);
            }
            return (int)mh$.invokeExact(array);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *umkaGetVersion()
     * }
     */
    public static FunctionDescriptor umkaGetVersion$descriptor() {
        return umkaGetVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *umkaGetVersion()
     * }
     */
    public static MethodHandle umkaGetVersion$handle() {
        return umkaGetVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *umkaGetVersion()
     * }
     */
    public static MemorySegment umkaGetVersion$address() {
        return umkaGetVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *umkaGetVersion()
     * }
     */
    public static MemorySegment umkaGetVersion() {
        var mh$ = umkaGetVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetVersion");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetMemUsage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_LONG_LONG,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetMemUsage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t umkaGetMemUsage(Umka *umka)
     * }
     */
    public static FunctionDescriptor umkaGetMemUsage$descriptor() {
        return umkaGetMemUsage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t umkaGetMemUsage(Umka *umka)
     * }
     */
    public static MethodHandle umkaGetMemUsage$handle() {
        return umkaGetMemUsage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t umkaGetMemUsage(Umka *umka)
     * }
     */
    public static MemorySegment umkaGetMemUsage$address() {
        return umkaGetMemUsage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t umkaGetMemUsage(Umka *umka)
     * }
     */
    public static long umkaGetMemUsage(MemorySegment umka) {
        var mh$ = umkaGetMemUsage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetMemUsage", umka);
            }
            return (long)mh$.invokeExact(umka);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaMakeFuncContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_INT,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaMakeFuncContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void umkaMakeFuncContext(Umka *umka, const UmkaType *closureType, int entryOffset, UmkaFuncContext *fn)
     * }
     */
    public static FunctionDescriptor umkaMakeFuncContext$descriptor() {
        return umkaMakeFuncContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void umkaMakeFuncContext(Umka *umka, const UmkaType *closureType, int entryOffset, UmkaFuncContext *fn)
     * }
     */
    public static MethodHandle umkaMakeFuncContext$handle() {
        return umkaMakeFuncContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void umkaMakeFuncContext(Umka *umka, const UmkaType *closureType, int entryOffset, UmkaFuncContext *fn)
     * }
     */
    public static MemorySegment umkaMakeFuncContext$address() {
        return umkaMakeFuncContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void umkaMakeFuncContext(Umka *umka, const UmkaType *closureType, int entryOffset, UmkaFuncContext *fn)
     * }
     */
    public static void umkaMakeFuncContext(MemorySegment umka, MemorySegment closureType, int entryOffset, MemorySegment fn) {
        var mh$ = umkaMakeFuncContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaMakeFuncContext", umka, closureType, entryOffset, fn);
            }
            mh$.invokeExact(umka, closureType, entryOffset, fn);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UmkaStackSlot *umkaGetParam(UmkaStackSlot *params, int index)
     * }
     */
    public static FunctionDescriptor umkaGetParam$descriptor() {
        return umkaGetParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UmkaStackSlot *umkaGetParam(UmkaStackSlot *params, int index)
     * }
     */
    public static MethodHandle umkaGetParam$handle() {
        return umkaGetParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UmkaStackSlot *umkaGetParam(UmkaStackSlot *params, int index)
     * }
     */
    public static MemorySegment umkaGetParam$address() {
        return umkaGetParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UmkaStackSlot *umkaGetParam(UmkaStackSlot *params, int index)
     * }
     */
    public static MemorySegment umkaGetParam(MemorySegment params, int index) {
        var mh$ = umkaGetParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetParam", params, index);
            }
            return (MemorySegment)mh$.invokeExact(params, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetUpvalue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetUpvalue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UmkaAny *umkaGetUpvalue(UmkaStackSlot *params)
     * }
     */
    public static FunctionDescriptor umkaGetUpvalue$descriptor() {
        return umkaGetUpvalue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UmkaAny *umkaGetUpvalue(UmkaStackSlot *params)
     * }
     */
    public static MethodHandle umkaGetUpvalue$handle() {
        return umkaGetUpvalue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UmkaAny *umkaGetUpvalue(UmkaStackSlot *params)
     * }
     */
    public static MemorySegment umkaGetUpvalue$address() {
        return umkaGetUpvalue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UmkaAny *umkaGetUpvalue(UmkaStackSlot *params)
     * }
     */
    public static MemorySegment umkaGetUpvalue(MemorySegment params) {
        var mh$ = umkaGetUpvalue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetUpvalue", params);
            }
            return (MemorySegment)mh$.invokeExact(params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetResult {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetResult");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UmkaStackSlot *umkaGetResult(UmkaStackSlot *params, UmkaStackSlot *result)
     * }
     */
    public static FunctionDescriptor umkaGetResult$descriptor() {
        return umkaGetResult.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UmkaStackSlot *umkaGetResult(UmkaStackSlot *params, UmkaStackSlot *result)
     * }
     */
    public static MethodHandle umkaGetResult$handle() {
        return umkaGetResult.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UmkaStackSlot *umkaGetResult(UmkaStackSlot *params, UmkaStackSlot *result)
     * }
     */
    public static MemorySegment umkaGetResult$address() {
        return umkaGetResult.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UmkaStackSlot *umkaGetResult(UmkaStackSlot *params, UmkaStackSlot *result)
     * }
     */
    public static MemorySegment umkaGetResult(MemorySegment params, MemorySegment result) {
        var mh$ = umkaGetResult.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetResult", params, result);
            }
            return (MemorySegment)mh$.invokeExact(params, result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *umkaGetMetadata(Umka *umka)
     * }
     */
    public static FunctionDescriptor umkaGetMetadata$descriptor() {
        return umkaGetMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *umkaGetMetadata(Umka *umka)
     * }
     */
    public static MethodHandle umkaGetMetadata$handle() {
        return umkaGetMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *umkaGetMetadata(Umka *umka)
     * }
     */
    public static MemorySegment umkaGetMetadata$address() {
        return umkaGetMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *umkaGetMetadata(Umka *umka)
     * }
     */
    public static MemorySegment umkaGetMetadata(MemorySegment umka) {
        var mh$ = umkaGetMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetMetadata", umka);
            }
            return (MemorySegment)mh$.invokeExact(umka);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaSetMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaSetMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void umkaSetMetadata(Umka *umka, void *metadata)
     * }
     */
    public static FunctionDescriptor umkaSetMetadata$descriptor() {
        return umkaSetMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void umkaSetMetadata(Umka *umka, void *metadata)
     * }
     */
    public static MethodHandle umkaSetMetadata$handle() {
        return umkaSetMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void umkaSetMetadata(Umka *umka, void *metadata)
     * }
     */
    public static MemorySegment umkaSetMetadata$address() {
        return umkaSetMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void umkaSetMetadata(Umka *umka, void *metadata)
     * }
     */
    public static void umkaSetMetadata(MemorySegment umka, MemorySegment metadata) {
        var mh$ = umkaSetMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaSetMetadata", umka, metadata);
            }
            mh$.invokeExact(umka, metadata);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaMakeStruct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaMakeStruct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *umkaMakeStruct(Umka *umka, const UmkaType *type)
     * }
     */
    public static FunctionDescriptor umkaMakeStruct$descriptor() {
        return umkaMakeStruct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *umkaMakeStruct(Umka *umka, const UmkaType *type)
     * }
     */
    public static MethodHandle umkaMakeStruct$handle() {
        return umkaMakeStruct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *umkaMakeStruct(Umka *umka, const UmkaType *type)
     * }
     */
    public static MemorySegment umkaMakeStruct$address() {
        return umkaMakeStruct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *umkaMakeStruct(Umka *umka, const UmkaType *type)
     * }
     */
    public static MemorySegment umkaMakeStruct(MemorySegment umka, MemorySegment type) {
        var mh$ = umkaMakeStruct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaMakeStruct", umka, type);
            }
            return (MemorySegment)mh$.invokeExact(umka, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetBaseType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetBaseType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetBaseType(const UmkaType *type)
     * }
     */
    public static FunctionDescriptor umkaGetBaseType$descriptor() {
        return umkaGetBaseType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetBaseType(const UmkaType *type)
     * }
     */
    public static MethodHandle umkaGetBaseType$handle() {
        return umkaGetBaseType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetBaseType(const UmkaType *type)
     * }
     */
    public static MemorySegment umkaGetBaseType$address() {
        return umkaGetBaseType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const UmkaType *umkaGetBaseType(const UmkaType *type)
     * }
     */
    public static MemorySegment umkaGetBaseType(MemorySegment type) {
        var mh$ = umkaGetBaseType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetBaseType", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetParamType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetParamType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetParamType(UmkaStackSlot *params, int index)
     * }
     */
    public static FunctionDescriptor umkaGetParamType$descriptor() {
        return umkaGetParamType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetParamType(UmkaStackSlot *params, int index)
     * }
     */
    public static MethodHandle umkaGetParamType$handle() {
        return umkaGetParamType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetParamType(UmkaStackSlot *params, int index)
     * }
     */
    public static MemorySegment umkaGetParamType$address() {
        return umkaGetParamType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const UmkaType *umkaGetParamType(UmkaStackSlot *params, int index)
     * }
     */
    public static MemorySegment umkaGetParamType(MemorySegment params, int index) {
        var mh$ = umkaGetParamType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetParamType", params, index);
            }
            return (MemorySegment)mh$.invokeExact(params, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetResultType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetResultType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetResultType(UmkaStackSlot *params, UmkaStackSlot *result)
     * }
     */
    public static FunctionDescriptor umkaGetResultType$descriptor() {
        return umkaGetResultType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetResultType(UmkaStackSlot *params, UmkaStackSlot *result)
     * }
     */
    public static MethodHandle umkaGetResultType$handle() {
        return umkaGetResultType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetResultType(UmkaStackSlot *params, UmkaStackSlot *result)
     * }
     */
    public static MemorySegment umkaGetResultType$address() {
        return umkaGetResultType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const UmkaType *umkaGetResultType(UmkaStackSlot *params, UmkaStackSlot *result)
     * }
     */
    public static MemorySegment umkaGetResultType(MemorySegment params, MemorySegment result) {
        var mh$ = umkaGetResultType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetResultType", params, result);
            }
            return (MemorySegment)mh$.invokeExact(params, result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetFieldType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetFieldType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetFieldType(const UmkaType *structType, const char *fieldName)
     * }
     */
    public static FunctionDescriptor umkaGetFieldType$descriptor() {
        return umkaGetFieldType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetFieldType(const UmkaType *structType, const char *fieldName)
     * }
     */
    public static MethodHandle umkaGetFieldType$handle() {
        return umkaGetFieldType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetFieldType(const UmkaType *structType, const char *fieldName)
     * }
     */
    public static MemorySegment umkaGetFieldType$address() {
        return umkaGetFieldType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const UmkaType *umkaGetFieldType(const UmkaType *structType, const char *fieldName)
     * }
     */
    public static MemorySegment umkaGetFieldType(MemorySegment structType, MemorySegment fieldName) {
        var mh$ = umkaGetFieldType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetFieldType", structType, fieldName);
            }
            return (MemorySegment)mh$.invokeExact(structType, fieldName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetMapKeyType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetMapKeyType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetMapKeyType(const UmkaType *mapType)
     * }
     */
    public static FunctionDescriptor umkaGetMapKeyType$descriptor() {
        return umkaGetMapKeyType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetMapKeyType(const UmkaType *mapType)
     * }
     */
    public static MethodHandle umkaGetMapKeyType$handle() {
        return umkaGetMapKeyType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetMapKeyType(const UmkaType *mapType)
     * }
     */
    public static MemorySegment umkaGetMapKeyType$address() {
        return umkaGetMapKeyType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const UmkaType *umkaGetMapKeyType(const UmkaType *mapType)
     * }
     */
    public static MemorySegment umkaGetMapKeyType(MemorySegment mapType) {
        var mh$ = umkaGetMapKeyType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetMapKeyType", mapType);
            }
            return (MemorySegment)mh$.invokeExact(mapType);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umkaGetMapItemType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            UnsafeUmka.C_POINTER,
            UnsafeUmka.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("umkaGetMapItemType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetMapItemType(const UmkaType *mapType)
     * }
     */
    public static FunctionDescriptor umkaGetMapItemType$descriptor() {
        return umkaGetMapItemType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetMapItemType(const UmkaType *mapType)
     * }
     */
    public static MethodHandle umkaGetMapItemType$handle() {
        return umkaGetMapItemType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const UmkaType *umkaGetMapItemType(const UmkaType *mapType)
     * }
     */
    public static MemorySegment umkaGetMapItemType$address() {
        return umkaGetMapItemType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const UmkaType *umkaGetMapItemType(const UmkaType *mapType)
     * }
     */
    public static MemorySegment umkaGetMapItemType(MemorySegment mapType) {
        var mh$ = umkaGetMapItemType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umkaGetMapItemType", mapType);
            }
            return (MemorySegment)mh$.invokeExact(mapType);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int _VCRUNTIME_DISABLED_WARNINGS = (int)4514L;
    /**
     * {@snippet lang=c :
     * #define _VCRUNTIME_DISABLED_WARNINGS 4514
     * }
     */
    public static int _VCRUNTIME_DISABLED_WARNINGS() {
        return _VCRUNTIME_DISABLED_WARNINGS;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final byte INT8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static byte INT8_MAX() {
        return INT8_MAX;
    }
    private static final short INT16_MAX = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static short INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final byte UINT8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static byte UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final short UINT16_MAX = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static short UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final byte INT_LEAST8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static byte INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final short INT_LEAST16_MAX = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static short INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final byte UINT_LEAST8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static byte UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final short UINT_LEAST16_MAX = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static short UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -2147483648
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final byte INT_FAST8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static byte INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 2147483647
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final byte UINT_FAST8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static byte UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 4294967295
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
}

